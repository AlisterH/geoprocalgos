# -*- coding: utf-8 -*-
"""
/***************************************************************************
 bcStackP3
                           A QGIS Processing algorithm
                       Create a stacked line vector layer

 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-05-19
        copyright            : (C) 2019 by GeoProc.com
        email                : info@geoproc.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'GeoProc.com'
__date__ = '2019-05-19'
__copyright__ = '(C) 2019 by GeoProc.com'
__revision__ = '$Format:%H$'

import os, codecs
from math import sin, cos, radians, sqrt
try:
    import numpy as np
    import pandas as pd
    is_dependencies_satisfied = True
except:
    is_dependencies_satisfied = False

from qgis.PyQt.QtGui import QIcon
from qgis.core import (QgsProcessingAlgorithm, QgsProcessing,
                       QgsProcessingUtils,
                       QgsProcessingParameterRasterLayer,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterBoolean,
                       QgsProcessingParameterField,
                       QgsProcessingParameterFile,
                       QgsProcessingParameterFileDestination,
                       QgsProcessingParameterNumber,
                       QgsProcessingParameterString,
                       QgsProcessingParameterEnum,
                       QgsProcessingParameterDefinition,
                       QgsProcessingParameterFeatureSink,
                       QgsProcessingFeatureSource,
                       QgsFields,
                       QgsFeature,
                       QgsGeometry,
                       QgsPoint,
                       QgsLineString,
                       QgsWkbTypes,
                       QgsFeatureRequest,
                       QgsProcessingException,
                       QgsStatisticalSummary,
                       QgsFeatureSink)

#-----------------------------------------------------------------------------------------
FlagsAdv = QgsProcessingParameterDefinition.FlagAdvanced
plugin_path = os.path.join(os.path.split(os.path.dirname(__file__))[0], 'geoprocAlgos')

the_url = 'http://www.geoproc.com/free/bcStackP3.htm'
help_string = """
"""
the_tags = ['geophysics','line','stacked','profile','vector','magnetic','electromagnetic',
            'gravity','electrical','radiometric','2D','survey']
#-----------------------------------------------------------------------------------------

class bcStackPAlgorithm(QgsProcessingAlgorithm):
    ''' Processing wrapper for the colour scale bar algorithm. '''
    #
    # Parameters used for stacking profiles
    THE_LAYER = 'THE_LAYER'
    FID_FLD   = 'FID_FLD'
    DATA_FLD  = 'DATA_FLD'
    LINE_FLD  = 'LINE_FLD'
    INVERTP   = 'INVERTP'
    SCALE     = 'SCALE'
    OFFSET    = 'OFFSET'
    JOINL     = 'JOINL'
    OUTPUT    = 'OUTPUT'
    DEP       = 'DEP'

    _default_output = 'stacked.shp'

    _the_strings = {"ERR":"ERROR",
                    "ERR_DEP":"numpy and pandas are required to run this algorithm",
                    "DEP_LST":"numpy, pandas",
                    "ERR_VECTOR":"ERROR: Input is not a vector!",
                    "bcStackP3":"Stacked profiles from point layer"
                   }

    _pstr = ['Input vector', 'Fiducial field (monotonically increasing number)',
             'Data field (numeric)', 'Line field',
             'Inverse profiles?',
             'Profile scale (relative to longest line length)',
             'Profile offset (relative to base line, +/-)',
             'Join profile to line?',
             'Output: Stacked profile vector file',
             'Output line vector file', 'Vector files (*.shp)', 'All files (*.*)']

    def __init__(self):
        super().__init__()
    #-------------------------------------------------------------------------------------

    def _define_params(self):
        ''' Define parameters needed. '''
        #
        #       [0] < 100  : "normal" parameter
        # 100 < [0] < 1000 : Advanced Parameter
        #       [0] > 1000 : Output parameter
        self.the_params = {
           self.THE_LAYER:    [1,self._pstr[0],'VectorLayer',
                               {'types':[QgsProcessing.TypeVectorPoint]},False],
           self.FID_FLD:      [2,self._pstr[1],'Field',{'parent':self.THE_LAYER},False],
           self.DATA_FLD:     [3,self._pstr[2],'Field',{'parent':self.THE_LAYER},False],
           self.LINE_FLD:     [4,self._pstr[3],'Field',{'parent':self.THE_LAYER},False],
           self.INVERTP:      [5,self._pstr[4],'Bool',{'defaultValue':False},True],
           self.SCALE:        [6,self._pstr[5],'NumberD',
                               {'defaultValue':3,'minValue':.0005,'maxValue':2000},True],
           self.OFFSET:       [7,self._pstr[6],'NumberD',
                               {'defaultValue':0.,'minValue':-1e5,'maxValue':1e5},True],
           self.JOINL:        [8,self._pstr[7],'Bool',{'defaultValue':False},True],
           self.OUTPUT:       [1001,self._pstr[8],'SINK',
                               {'type':QgsProcessing.TypeVectorLine},True]
        }
    #-------------------------------------------------------------------------------------

    def _set_param(self, param):
        ''' Set parameter. '''
        #
        arg = self.the_params[param]
        what = arg[2]
        optional = arg[4]
        the_str = arg[1]
        qparam = None
        #
        if what == 'RasterLayer':
            qparam = QgsProcessingParameterRasterLayer(
                     param,
                     self.tr(the_str),
                     optional = optional
                )
        elif what == 'VectorLayer':
            qparam = QgsProcessingParameterFeatureSource(
                     param,
                     self.tr(the_str),
                     types = arg[3]['types'],
                     optional = optional
                )
        elif what == 'File':
            qparam = QgsProcessingParameterFile(
                     param,
                     self.tr(the_str),
                     extension = arg[3]['ext'],
                     optional = optional
                )
        elif what == 'Field':
            qparam = QgsProcessingParameterField(
                     param,
                     self.tr(the_str),
                     parentLayerParameterName=arg[3]['parent'],
                     optional = optional
                )
        elif what == 'Enum':
            qparam = QgsProcessingParameterEnum(
                     param,
                     self.tr(the_str),
                     [self.tr(s) for s in arg[3]['list']],
                     defaultValue = arg[3]['defaultValue'],
                     optional = optional
                )
        elif what == 'String':
            qparam = QgsProcessingParameterString(
                     param,
                     self.tr(the_str),
                     defaultValue = arg[3]['defaultValue'],
                     optional = optional
                )
        elif what == 'NumberD':
            qparam = QgsProcessingParameterNumber(
                     param,
                     self.tr(the_str),
                     type = QgsProcessingParameterNumber.Double,
                     defaultValue = arg[3]['defaultValue'],
                     minValue = arg[3]['minValue'],
                     maxValue = arg[3]['maxValue'],
                     optional = optional
                )                
        elif what == 'NumberI':
            qparam = QgsProcessingParameterNumber(
                     param,
                     self.tr(the_str),
                     type = QgsProcessingParameterNumber.Integer,
                     defaultValue = arg[3]['defaultValue'],
                     minValue = arg[3]['minValue'],
                     maxValue = arg[3]['maxValue'],
                     optional = optional
                )                
        elif what == 'Bool':
            qparam = QgsProcessingParameterBoolean(
                     param,
                     self.tr(the_str),
                     defaultValue = arg[3]['defaultValue'],
                     optional = optional
                )                
        elif what == 'FileDestination':
            qparam = QgsProcessingParameterFileDestination(
                     param,
                     self.tr(the_str),
                     defaultValue = arg[3]['defaultValue'],
                     fileFilter = arg[3]['FILTER'],
                     optional = optional
                )
        elif what == 'SINK':
            qparam =  QgsProcessingParameterFeatureSink(self.OUTPUT, 
                      self.tr(the_str),
                      type = arg[3]['type'],
                      optional = optional
                )
        #
        if qparam != None:
            if arg[0] < 100:
                self.addParameter(qparam)
            elif arg[0] < 1000:
                qparam.setFlags(qparam.flags() | FlagsAdv)
                self.addParameter((qparam))
            else:
                self.addParameter(qparam, True)
    #-------------------------------------------------------------------------------------

    def _do_profile(self, ar, inv, scale, offset):
        ''' Create profile for current line.
            ar: current line (pandas DataFrame)
            inv: 1 (default) or -1 to reverse profile
            scale: scale profile relative to max-profile length
            offset: move profile relative to line trace

            Return: 2 numpy arrays: X and new-Y = profile coordinates
        '''
        #
        nar = np.array(ar[['X','Y']])
        line_pts = [QgsPoint(x,y) for x,y in nar]

        # Rotate line to horizontal
        aziN   = line_pts[0].azimuth(line_pts[-1]) # angle positive clockwise from North
        azi    = -(aziN - 90.)
        cx, cy = nar[0, 0], nar[0, 1]              # center of rotation

        # Rotate line to horizontal    
        theta  = radians(-azi)
        co, si = cos(theta), sin(theta)
        tx, ty = nar[:,0] - cx, nar[:,1] - cy
        px = tx * co - ty * si + cx
        py = tx * si + ty * co + cy

        # Take care of profile direction and line vs tie-line
        bT = False
        if self.azi != None and abs(int(azi) - self.azi) > 20:
            if ((azi > self.azi and abs(int(azi) - (self.azi +180)) < 20) or
                (azi < self.azi and abs(int(azi) - (self.azi -180)) < 20)):
                inv = -inv
            elif self.aziT == None:
                # first tie line
                self.aziT = int(azi)
                bT = True
            if self.aziT != None and abs(int(azi) - self.aziT) > 20:
                if ((azi > self.aziT and abs(int(azi) - (self.aziT +180)) < 20) or
                    (azi < self.aziT and abs(int(azi) - (self.aziT -180)) < 20)):
                    inv = -inv
                    bT = True
            elif self.aziT != None and abs(int(azi) - self.aziT) <= 20:
                    bT =True
        if bT:
            inv = -inv
        # Change Y-coords to scaled data
        mn = py.mean()  # average Y-coord
        ar['Yb'] = inv * (scale * (ar.Data - self.dmean) * self.mult + offset) + mn

        # Rotate line back to original angle
        theta  = radians(azi)
        co, si = cos(theta), sin(theta)
        tx, ty = px - cx, np.array(ar.Yb) - cy
        px1 = tx * co - ty * si + cx   # New X-coords
        py1 = tx * si + ty * co + cy   # New Y-coords
        #
        if self.azi == None:
            self.azi = int(azi)
        return px1, py1  # profile coords
    #-------------------------------------------------------------------------------------

    def initAlgorithm(self, config):
        ''' Here we define the inputs and output of the algorithm. '''
        #
        if is_dependencies_satisfied:
            # Prepare all parameters needed for plotting the colour bar
            self._define_params()
            for param in sorted(self.the_params, key=self.the_params.__getitem__):
                self._set_param(param)

        else:
            qparam = QgsProcessingParameterString(
                    self.DEP,
                    self.tr(self._the_strings["ERR_DEP"]),
                    defaultValue = self.tr(self._the_strings["DEP_LST"]),
                    optional = False
                )
            self.addParameter(qparam)

        self.tmpDir = QgsProcessingUtils.tempFolder()
        self._error = ''
        self.azi    = None
        self.aziT   = None
    #-------------------------------------------------------------------------------------

    def processAlgorithm(self, parameters, context, feedback):
        ''' Here is where the processing itself takes place. '''
        #
        if not is_dependencies_satisfied:
            return {}

        the_layer = self.parameterAsSource(parameters, self.THE_LAYER, context)
        if the_layer is None:
            raise QgsProcessingException(self.invalidSourceError(parameters,
                                                                 self.THE_LAYER))
        #
        fidu_fld = self.parameterAsString(parameters, self.FID_FLD, context)
        data_fld = self.parameterAsString(parameters, self.DATA_FLD, context)
        line_fld = self.parameterAsString(parameters, self.LINE_FLD, context)
        invP = self.parameterAsBool(parameters, self.INVERTP, context)
        scale =  self.parameterAsDouble(parameters, self.SCALE, context)
        offset = self.parameterAsDouble(parameters, self.OFFSET, context)
        join_to_line = self.parameterAsBool(parameters, self.JOINL, context)

        data = the_layer.fields().at(the_layer.fields().lookupField(data_fld))
        fidu = the_layer.fields().at(the_layer.fields().lookupField(fidu_fld))
        if not data.isNumeric() or not fidu.isNumeric():
            raise QgsProcessingException(self.invalidSourceError(parameters,
                                                             self.THE_LAYER))

        line = the_layer.fields().at(the_layer.fields().lookupField(line_fld))
        data_ix = the_layer.fields().lookupField(data_fld)
        line_ix = the_layer.fields().lookupField(line_fld)
        fidu_ix = the_layer.fields().lookupField(fidu_fld)

        # Set output vector layer
        output_wkb = QgsWkbTypes.LineString
        if QgsWkbTypes.hasM(the_layer.wkbType()):
            output_wkb = QgsWkbTypes.addM(output_wkb)
        if QgsWkbTypes.hasZ(the_layer.wkbType()):
            output_wkb = QgsWkbTypes.addZ(output_wkb)

        # Keep line into stacked profile vector
        line_def = the_layer.fields().at(line_ix)
        fields = QgsFields()
        if line_def is not None:
            fields.append(line_def)
        (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT, context, fields,
                                               output_wkb, the_layer.sourceCrs())
        if sink is None:
            raise QgsProcessingException(self.invalidSinkError(parameters, self.OUTPUT))

        # Get the features and fields of interest
        features = the_layer.getFeatures(QgsFeatureRequest().setSubsetOfAttributes(
                       [fidu_ix, line_ix, data_ix]), 
                       QgsProcessingFeatureSource.FlagSkipGeometryValidityChecks)

        # Find min/max of data values for all lines and save each line in a csv file
        # Then process each line separately: can have any number of lines...
        lines = []
        xyzf  = []
        lineN = ''
        nL    = 0
        TL    = 0.
        total = 60.0 / the_layer.featureCount() if the_layer.featureCount() else 0
        stat  = QgsStatisticalSummary()
        for current, ft in enumerate(features):
            if feedback.isCanceled():
                break
            feedback.setProgress(int(current * total))
            if not ft.hasGeometry():
                continue
            #
            stat.addVariant(ft[data.name()])
            #
            if ft[line.name()] != lineN:
                if xyzf != []:
                    lines.append([lineN, nL])
                    the_csv = os.path.join(self.tmpDir, '%010d.csv' % lineN)
                    with codecs.open(the_csv, 'w', 'utf-8') as fo:
                        fo.write('X,Y,FID,Data\n')
                        for ar in xyzf:
                            fo.write(','.join(map(str, ar)))
                            fo.write('\n')
                    le = sqrt((xyzf[0][0] - xyzf[-1][0])**2 + 
                              (xyzf[0][1] - xyzf[-1][1])**2)
                    if le > TL:
                        TL = le
                    xyzf = []
                    nL = 0
                lineN = ft[line.name()]
            #
            point = ft.geometry().constGet().clone()
            xyzf.append([point.x(), point.y(), ft[fidu.name()], ft[data.name()]])
            nL += 1
        # last line
        if xyzf != []:
            lines.append([lineN, nL])
            the_csv = os.path.join(self.tmpDir, '%010d.csv' % lineN)
            with codecs.open(the_csv, 'w', 'utf-8') as fo:
                fo.write('X,Y,FID,Data\n')
                for ar in xyzf:
                    fo.write(','.join(map(str, ar)))
                    fo.write('\n')
            le = sqrt((xyzf[0][0] - xyzf[-1][0])**2 + 
                      (xyzf[0][1] - xyzf[-1][1])**2)
            if le > TL:
                TL = le
        #
        stat.finalize()
        self.dmean = stat.mean()
        self.mult = TL / (stat.max() - stat.min())
        #
        if invP:
            iv = -1
        else:
            iv = 1
        total = 40.0 / (nL + 1)
        # For each line:
        for current, z in enumerate(lines):
            line = z[0]
            if feedback.isCanceled():
                break
            if not ft.hasGeometry():
                continue
            feedback.setProgress(int(current * total) + 60.)

            # Read line back from csv
            the_csv = os.path.join(self.tmpDir, '%010d.csv' % int(line))
            ar = pd.read_csv(the_csv)
            ar = ar.sort_values('FID')

            # Create the profile
            px, py = self._do_profile(ar, iv, scale, offset)

            #Construct vector layer
            f = QgsFeature()
            f.setAttributes([line,])
            line_pts = [QgsPoint(x,y) for x,y in zip(px, py)]
            if join_to_line:
                # Join profile to its line
                e = len(ar) - 1
                ar0 = [QgsPoint(ar.X[0],ar.Y[0]),]
                ar1 = [QgsPoint(ar.X[e],ar.Y[e]),]
                line_pts = ar0 + line_pts + ar1
            #
            f.setGeometry(QgsGeometry(QgsLineString(line_pts)))
            sink.addFeature(f, QgsFeatureSink.FastInsert)
            # Delete temp csv file
            try:
                os.remove(the_csv)
            except:
                pass

        return {self.OUTPUT:dest_id}
    #-------------------------------------------------------------------------------------

    def get_error(self):
        ''' Return the error value. '''
        #
        return self.tr(self._error)
    #-------------------------------------------------------------------------------------

    def icon(self):
        ''' Returns a QIcon for the algorithm. '''
        #
        return QIcon(os.path.join(plugin_path, 'res', 'bcStackP.svg'))
    #-------------------------------------------------------------------------------------

    def svgIconPath(self):
        ''' Returns a path to an SVG version of the algorithm's icon. '''
        #
        return os.path.join(plugin_path, 'res', 'bcStackP.svg')
    #-------------------------------------------------------------------------------------

    def helpUrl(self):
        ''' Returns a url pointing to the algorithm's help page. '''
        #
        return the_url
    #-------------------------------------------------------------------------------------

    def shortHelpString(self):
        ''' Returns a localised short helper string for the algorithm. '''
        #
        return self.tr(help_string)
    #-------------------------------------------------------------------------------------

    def name(self):
        '''
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        '''
        return 'bcStackP3'
    #-------------------------------------------------------------------------------------

    def displayName(self):
        '''
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        '''
        return self.tr(self._the_strings["bcStackP3"])
    #-------------------------------------------------------------------------------------

    def tags(self):
        return self.tr(the_tags)
    #-------------------------------------------------------------------------------------

    def group(self):
        '''
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        '''
        return str(self.groupId()).capitalize()
    #-------------------------------------------------------------------------------------

    def groupId(self):
        '''
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        '''
        return 'vector'
    #-------------------------------------------------------------------------------------

    def tr(self, string):
        ''' No translation of strings. '''
        #
        return string
    #-------------------------------------------------------------------------------------

    def createInstance(self):
        ''' Creates a new instance of the algorithm class. '''
        #
        return bcStackPAlgorithm()
    #-------------------------------------------------------------------------------------